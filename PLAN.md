# kubectl-guard Implementation Plan

A CLI wrapper for kubectl that protects against accidental commands on production clusters.

## Overview

kubectl-guard intercepts kubectl commands, checks if the current context is protected, and prompts for confirmation on state-altering commands.

## Core Behavior

```
kubectl <command> [args...]
           ↓
    Get current context (kubectl config current-context)
           ↓
    Is context in protected list?
           │
     ┌─────┴─────┐
     No          Yes
     ↓           ↓
  Forward    Is command state-altering?
  to kubectl      │
             ┌────┴────┐
             No        Yes
             ↓         ↓
          Forward   Prompt for confirmation
          to kubectl    │
                   ┌────┴────┐
                   Yes       No
                   ↓         ↓
               Forward    Exit(1)
               to kubectl
```

## First-Run Setup

When `~/.kubectl-guard.yaml` does not exist:

1. Display welcome message
2. Query all contexts from kubeconfig (`kubectl config get-contexts`)
3. Present interactive multi-select UI
4. User selects contexts to protect (or chooses "none")
5. Write config file
6. Instruct user to re-run their command

## Project Structure

```
kubectl-guard/
├── main.go              # Entry point, arg parsing
├── config/
│   ├── config.go        # Config file loading/saving
│   └── setup.go         # First-run setup wizard
├── guard/
│   ├── guard.go         # Core protection logic
│   ├── commands.go      # Command classification (safe vs state-altering)
│   └── context.go       # Kubectl context helpers
├── ui/
│   └── prompt.go        # Interactive prompts (multi-select, confirm)
├── go.mod
├── go.sum
├── README.md
├── Makefile
└── .goreleaser.yaml     # Optional: for releases
```

## Dependencies

| Package | Purpose |
|---------|---------|
| `github.com/spf13/cobra` | CLI framework |
| `github.com/charmbracelet/bubbletea` | Interactive TUI for setup wizard |
| `github.com/charmbracelet/lipgloss` | Terminal styling |
| `gopkg.in/yaml.v3` | Config file parsing |

## Config File

Location: `~/.kubectl-guard.yaml`

```yaml
# kubectl-guard configuration
# Generated by first-run setup

protected_contexts:
  - prod-cluster
  - production-*        # Supports glob patterns
  - "arn:aws:eks:*:*:cluster/prod-*"  # AWS EKS ARNs

# Future options (not in v1)
# mode: confirm          # confirm | block | warn
# safe_commands_override: []
# dangerous_commands_override: []
```

## Command Classification

### Safe Commands (passthrough on protected contexts)

```go
var safeCommands = []string{
    "get",
    "describe",
    "logs",
    "top",
    "explain",
    "api-resources",
    "api-versions",
    "version",
    "cluster-info",
    "config",        // view, get-contexts, current-context
    "auth",          // can-i, whoami
    "wait",          // read-only wait
    "diff",          // shows diff without applying
}
```

### State-Altering Commands (require confirmation)

```go
var stateAlteringCommands = []string{
    "apply",
    "create",
    "delete",
    "patch",
    "replace",
    "edit",
    "scale",
    "rollout",       // restart, undo, pause, resume
    "autoscale",
    "expose",
    "run",
    "set",           // image, env, resources, etc.
    "label",
    "annotate",
    "taint",
    "drain",
    "cordon",
    "uncordon",
    "exec",          // can modify state inside pod
    "cp",            // copies files to/from pods
    "debug",
    "attach",
}
```

## Implementation Steps

### Phase 1: Core Infrastructure

1. **Initialize Go module**
   - `go mod init github.com/cameronlockhart/kubectl-guard`
   - Add dependencies

2. **Config package**
   - `Load()` - read config from `~/.kubectl-guard.yaml`
   - `Save()` - write config file
   - `Exists()` - check if config exists
   - `ConfigPath()` - return config file path

3. **Context helpers**
   - `GetCurrentContext()` - shell out to `kubectl config current-context`
   - `GetAllContexts()` - shell out to `kubectl config get-contexts`
   - `IsProtected(context string, patterns []string) bool` - glob matching

### Phase 2: Command Classification

4. **Command classification**
   - `IsSafeCommand(args []string) bool`
   - `IsStateAltering(args []string) bool`
   - Handle subcommands: `rollout restart` is state-altering, `rollout status` is safe
   - Handle flags: ignore flags when classifying

### Phase 3: Setup Wizard

5. **Interactive setup**
   - Bubbletea model for multi-select
   - List all contexts with checkboxes
   - "None" option to skip protection
   - Save selections to config

### Phase 4: Main Logic

6. **Guard logic**
   - Wire everything together
   - Confirmation prompt: `"⚠️  [command] on protected context [ctx]. Confirm? [y/N]: "`
   - Forward to kubectl via `os.Exec` (replaces process)

7. **CLI structure**
   - `kubectl-guard [kubectl args...]` - main passthrough
   - `kubectl-guard config` - re-run setup wizard
   - `kubectl-guard config --list` - show protected contexts
   - `kubectl-guard config --add <ctx>` - add context
   - `kubectl-guard config --remove <ctx>` - remove context

### Phase 5: Polish

8. **Error handling**
   - kubectl not found
   - Invalid kubeconfig
   - No contexts available
   - Permission denied on config file

9. **Makefile**
   - `make build` - build binary
   - `make install` - install to ~/go/bin or /usr/local/bin
   - `make test` - run tests

10. **Documentation**
    - README with installation and usage
    - Shell alias instructions

## User Installation

```bash
# Build and install
go install github.com/cameronlockhart/kubectl-guard@latest

# Or from source
git clone https://github.com/cameronlockhart/kubectl-guard
cd kubectl-guard
make install

# Add alias to shell config (~/.zshrc or ~/.bashrc)
alias kubectl='kubectl-guard'

# First run triggers setup
kubectl get pods
# → Setup wizard appears
```

## Example Session

```bash
# First run (no config)
$ kubectl get pods

  kubectl-guard: First-time Setup

  Select contexts to protect (space to toggle, enter to confirm):

  [ ] docker-desktop
  [ ] minikube
  [x] prod-cluster
  [x] prod-us-east-1
  [ ] staging

  [n] None - don't protect any contexts

✓ Saved to ~/.kubectl-guard.yaml
  Protected: prod-cluster, prod-us-east-1

Re-run your command to continue.

# Normal usage - unprotected context
$ kubectl config use-context minikube
$ kubectl delete pod nginx
pod "nginx" deleted

# Protected context - safe command
$ kubectl config use-context prod-cluster
$ kubectl get pods
NAME    READY   STATUS
nginx   1/1     Running

# Protected context - state-altering command
$ kubectl delete pod nginx
⚠️  delete on protected context: prod-cluster
Confirm? [y/N]: n
Aborted.

$ kubectl apply -f deployment.yaml
⚠️  apply on protected context: prod-cluster
Confirm? [y/N]: y
deployment.apps/nginx configured
```

## Future Enhancements (Not in v1)

- **Audit log**: Log all confirmed commands on protected contexts
- **Block mode**: Completely block state-altering commands (no confirmation option)
- **Namespace protection**: Protect specific namespaces, not just contexts
- **Custom command lists**: User-configurable safe/dangerous commands
- **Team config**: Shared config file for teams (e.g., in repo)
- **Dry-run enforcement**: Auto-add `--dry-run=client` first, show diff, then confirm

## Testing Strategy

1. **Unit tests**
   - Config loading/saving
   - Command classification
   - Context glob matching

2. **Integration tests**
   - Mock kubectl binary
   - Test full flow with test kubeconfig

3. **Manual testing**
   - Test with real clusters
   - Test setup wizard UX
